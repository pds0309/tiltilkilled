

## item 76. 가능한 한 실패 원자적으로 만들라

<br>

<br>

### 실패 원자적?

<br>

호출된 메소드가 실패하더라도 해당 객체는 메소드 호출 전 상태를 유지해야 한다는 것을 `failure-atomic` 이라고 한다.

<br>

<br>

### 실패 원자적으로 만들기

<br>

**`불변객체`로 설계하는 것**

- 불변객체는 생성 시점에 고정되어 절대 변하지 않기 때문에 메소드가 실패한다고 기존 객체가 불안정한 상태로 변경될 일이 없다는 것이 보장된다.


<br>

#### 가변객체는?

**1. 작업 수행에 앞서 매개변수의 유효성을 검사하면 내부 상태 변경 전 잠재적 예외 가능성을 걸러낼 수 있다,**

<br>

```java

public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result;
}

```

<br>

이 메소드의 경우 `if문` 이 없어도 예외를 던지지만 `size` 가 음수로 상태가 변경 되어 다음번 호출에도 영향을 주는 등의 불확실한 결과를 만들어낼 여지가 있다.

게다가 이 때 던져지는 인덱스 범위 예외인 `ArrayIndexOutOfBoundsException` 은 현재 기능에서 추상화 수준이 어울리지 않는다.

앞서 `if문` 으로 유효성 검사를 미리 해주어 추상화 수준에 맞는 예외를 던질 수 있어 어떤 상황인지 누구나 알 수 있으며 원치 않는 상태변화로 발생될 사이드 이펙트도 제거된 형태이다.


<br>


**2. 실패 가능성이 있는 코드를 객체 상태 변화 코드 앞에 배치하여 해결할 수 있다.**

<br>

**3. 임시 복사 객체를 만들어 작업을 수행한다.**

- 임시복사본에서 작업을 하고 성공 시 원래 객체와 교체하는 것

<br>

**4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성해 작업 전 상태로 되돌리는 방법**

<br>

<br>

### 실패원자성을 항상 달성할 수 있는 것은 아님

<br>

두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 객체의 일관성이 깨지며 `ConcurrentModificationException` 을 던지긴 하지만 그 객체가 쓸 수 있는 적절한 상태라고 가정해서는 안됨

<br>

실패원자적으로 만들 수 있더라도 비용이 매우 클 경우가 있다,

<br>

**기본적으로는 메소드 명세에 기술한 예외라면 예외 발생시 객체의 상태는 메소드 호출 전과 똑같아야 한다는 것이다.**

- 그렇지 않다면 API 설명에 명시해야 한다.

