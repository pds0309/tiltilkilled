


### item 49. 매개변수가 유효한지 검사하라

<br>


메소드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.

이런 제약은 반드시 문서화하고 메소드 동작 시작 전에 검사해야 한다.

> 오류는 가능한 빨리 발생하는 곳에서 잡아야 한다.

<br>

메소드 동작(몸체) 시작 전에 파라미터를 확인하면 잘못된 값이 넘어왔을 때 즉시 깔끔하게 예외를 던지게 할 수 있다.

파라미터 검사를 제대로 하지 않으면 **메소드 수행 중간에 모호한 예외를 던지며 실패하거나 메소드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.**

메소드 자체가 문제없이 수행이 되었지만 객체 상태를 이상하게 만들어 놓아 미래의 알 수 없는 시점에 다른 곳에서 오류를 내게 된다면 치명적이다.

<br>

**public 과 protected 메소드는 파라미터 값이 잘못되었을 때 던지는 예외를 문서화 해야 한다**

- `@throws` 자바독 태그를 사용하자

- 매개변수 제약을 문서화한다면 제약 어겼을 때 발생하는 예외도 함께 기술하자.


```java
/**
* @param m 계수(양수일 것)
* @return 현재 값 mod m
* @throws ArithmeticException : m 이 0 보다 작거나 같으면 발생한다.
*/
public BigInteger mod(BigInteger m) {
    if (m.sigNum() <= 0) {
        throw new ArithmeticException("계수(m) 은 양수여야 한다." + m);
    }
}
```

이 메소드의 경우 m이 null이면 `sigNum()` 을 호출할 때 NPE 가 발생하지만 그와 관련된 설명은 없다.

그 이유는 이 설명이 `BIgInteger` 클래스 수준에서 기술되었기 때문이다.

클래스 수준 주석은 그 클래스 모든 public 메소드에 적용되므로 각 메소드에 일일이 기술하는 것 보다 훨씬 깔끔하다.

`@Nullable` 같은 것으로 null이 가능함을 알려줄 수 있으나 표준은 아니다.


<br>

자바 7에 추가된 `java.util.Objects.requireNonNull` 메소드를 사용해 null 검사를 수동으로 하지 않아도 된다.

원하는 메시지도 설정 가능하고 입력을 그대로 반환하여 값을 사용하는 동시에 null 체크가 가능하다.


> requireNonNull 내부 구조

```java
public static <T> T requireNonNull(T obj) {
    if (obj == null) {
        throw new NullPointerException();
    return obj;
    }
}

```

**왜 쓸까?**

- fail fast

```java
B b = new B(a);
```

기존의 경우 따로 처리하지 않으면 사용 시점에 예외를 통해 잘못되었음을 알 수 있지만

사용 시 다음과 같이 **생성 시점에 발생되는 예외를 통해 알 수 있다**


- explicity 

```java
public class B {
    A a;

    public B(A a) {
        this.a = Objects.requireNonNull(a);
    }
}
```

코드 상에서 null이 아니어야함을 명시해준다.

미래에 개발자가 이를 보고 명시적으로 식별할 수 있다.



<br>


**단언문 사용하기**

공개되지 않은 메소드라면 스스로 우리가 메소드 호출 상황을 통제할 수 있다.

따라서 오직 유효한 값만이 메소드에 넘겨질 것이라는 것을 우리가 보증할 수 있게 된다.

`public` 이 아닌 메소드에서 단언문 `assert` 를 사용해 매개변수 유효성 검증을 하자.

<br>


```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
}
```

<br>

단언문들은 자신이 단언한 조건이 항상 참일 것이라고 선언한다.

유효성 검사에 실패할 경우 `AssertionError` 를 던지며 **런타임에 아무 효과도 성능 저하도 없다**


<br>


**사용은 당장 하지 않지만 나중에 쓰기 위해 할당하는 매개변수를 특히 더 신경써서 검사하자**

당장 사용하게 된다면 당장 예외가 뜨니 괜찮지만 당장 null 인데 나중에 다른 곳에서 사용해야 할 경우에 예외가 발생했을 시 

디버깅 추적이 상당히 어려워 질 수  있다.


생성자는 `나중에 사용하려고 저장하는 매개변수의 유효성을 검사하라` 원칙의 특수 사례다.

**생성자 매개변수 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다**


<br>


**비실용적이거나 비용이 높을 경우 매개변수 유효성 검사를 하지 않아야 할 수 있다**

예를 들어 `Collections.sort(List)` 같은 경우 컬렉션 내부 값들이 서로 비교가 가능한지 먼저 검사하고 비교가 안될 경우 `ClassCastException` 을 던진다.

이런 경우 비교 전에 리스트 내부의 객체들이 비교 가능한지 여부를 미리 검사할 필요가 없다.


<br>


**요약**

- 메소드나 생성자 작성 시 매개변수들에 어떤 제약이 있을지 잘 생각해라

- 제약들을 문서화하고 **메소드 코드 시작 부분에서 명시적으로 검사하라**


