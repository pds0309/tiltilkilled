

## item26. 제네릭 로우 타입은 사용하지 마라


**제네릭 클래스 or 인터페이스**

- 클래스 또는 인터페이스의 선언에 `타입 매개변수` 가 쓰이는 경우를 말함

- 통틀어 `제네릭 타입` 이라고 한다.

<br>

**각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다**

- 클래스 이름이 나오고 꺾쇠 괄호 안에 실 타입 매개변수들을 나열함

```java

List<E> li; // 타입 매개변수 E를 받는 제네릭 인터페이스

List<String> list; // 원소의 타입이 String 인 list 를 뜻함
```

**로우 타입**

- 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 때를 말한다.
	- `List<E>` 의  `List`


> 로우 타입으로의 컬렉션 사용 

```java
for(Iterator i = stamps.iterator(); i.hasNext(); ) {
	Stamp stamp = (Stamp) i.next(); // ClassCastException
	stamp.cancel();
}
```

**왜 사용하면 안됨?**

- 컬렉션에 맞는 의도된 타입이 있을 것인데 의도치 않은 타입으로 사용될 때에 대한 발견을 컴파일 시점에 알지 못함

- 로우 타입을 사용하면 제네릭이 줄 수 있는 안전성과 표현력을 잃는 것이라고 할 수 있음
	- 기존 레거시 코드와의 호환 떄문에 강제하지 않았을 뿐 반드시 타입을 명시해야 함

<br>

제네릭 타입을 활용해 내가 선언한 타입의 인스턴스로만 사용을 취급한다고 명시해 줄 수 있는 것임

> Stamp 타입 이외의 타입으로 해당 리스트를 사용하려고 하면 컴파일 시점에 오류를 보여줌

```java
List<Stamp> stamps;
```

<br>

**List<Object> 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다**

- 로우 타입과의 차이는 타입에 대한 선언을 컴파일러에게 말해줬냐 아니냐의 차이이다.

- `Object` 의 사용은 모든 타입을 허용한다는 사실을 컴파일러에게 일러준 것이라고 볼 수 있다.


<br>

**컬렉션을 사용하는데 실제 타입 매개변수가 무엇인지 모르거나 무엇인지 신경 쓰고 싶지 않을 때**

- 로우 타입 대신에 `비한정 와일드 카드 타입` 을 사용해라
	- `EX) Set<E> => Set<?>


<br>

**로우 타입을 사용할 수 있는 경우**

- `class` 리터럴에는 로우 타입을 사용한다.
	- `OK` : List.class, String[].class
	- `NO` : List<String>.class, List<?>.class

- `instanceof`
	- 런타임에는 제네릭 타입 정보가 지워지기 때문에 `instanceof` 연산자는 비한정 와일드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
	- 로우 타입이나 비한정 와일드 카드나 똑같이 동작함

```java
if(o instanceof Set) {
	Set<?> s = (Set<?>) o;
}
```


<br>

**요약**

- 제네릭 로우 타입  런타임 예외 유발 가능하니 쓰지말 것

 