

## item61. 박싱된 기본 타입보다는 기본 타입을 사용하라


- 오토박싱과 오토 언박싱 때문에 두 타입을 크게 구분하지 않고 사용할 수 있지만 어떤 타입을 사용하냐의 차이는 분명히 있다.

<br>

**기본 타입은 값만 가지나 박싱된 기본 타입은 식별성도 가진다**

- 다시 말해 박싱 타입의 두 인스턴스는 `값`이 같아도 다르다고 식별될 수가 있다.

**기본 타입의 값은 항상 유효한데 반해 박싱 타입은 null 을 가질수 있다**

**기본 타입이 시간과 메모리 사용 면에서 더 효울적이다**


<br>


### 박싱 타입에서 `==` 연산자 사용시 주의하자


```java

Comparator<Integer> naturalOrder = 
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

```

비교 연산 `<` 의 경우에는 오토박싱된 `Integer` 인스턴스가 기본 타입 값으로 변환되어 동작하기 때문에 문제가 없다.

하지만 `==` 의 경우 `두 객체의 참조` 에 대한 식별성 검사가 들어가기 때문에 같은 값을 가지고 있더라도 다른 결과가 나올 것이다.


- 위 처럼 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()` 를 사용하자

- 비교자를 직접 만들면 비교자 생성 메소드나 기본 타입을 받는 정적 `compare` 메소드를 사용하자


<br>

### 기본타입과 박싱타입을 혼용해 사용하면 박싱이 자동으로 풀린다

```java
public class Hi {
	Integer i;
	void hi() {
		if ( i == 1) {
			System.out.println("안녕");
		}
	}

}
```

위의 메소드는 `NullPointerException` 을 던진다.

`==` 으로 기본타입 `int = 1` 과 박싱타입 `Integer` 를 비교하고 있기 때문에 박싱타입인 `Integer` 는 자동으로 `int` 로 변환된다.

이 때 `Integer` 는 초기화 되지 않아 null을 가지고 있기 때문에 기본타입으로 언박싱되면서 `NullPointerException` 을 뱉는다.

<br>

### 비효율적인 상황이 있다.

```java
public class Hi {
	Long sum = 0L;
	void hi() {
		for(long i = 0; i < 5; i ++) {
			sum += i;
		}
	}
}
```

위의 메소드는 반복적으로 박싱타입 `Long sum` 에 기본타입으로 더하는 연산을 하고 있다.

이 경우 박싱과 언박싱이 자동으로 반복하여 일어나기 때문에 상당히 성능이 안좋아진다.



<br>

### 박싱 타입을 언제 쓸까?

- 컬렉션의 원소, 키 , 값

- 매개변수화 타입이나 매개변수화 메소드의 타입 매개변수로 박싱 타입을 쓴다.

- 리플렉션을 통해 메소드를 호출할 때도 박싱 타입을 사용한다.


<br>

