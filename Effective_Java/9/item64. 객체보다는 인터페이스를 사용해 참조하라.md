

## item 64. 객체보다는 인터페이스를 사용해 참조하라.

<br>


> Item 51. 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라.

다음의 말을 확장하면 **객체는 클래스가 아닌 인터페이스로 참조하라** 이다.

<br>

적합한 인터페이스가 있으면 매개변수 뿐 아니라 반환값, 변수, 필드 등을 전부 인터페이스 타입으로 선언하라.

실제 클래스 사용은 **생성자로 인스턴스화** 할 때 뿐이다.

<br>

**Compliant**

```java
Set<Integer> set = new LinkedHashSet<>();
```

**Noncompliant**

```java
LinkedHashSet<Integer> set = new LinkedHashSet<>();
```

인터페이스 타입으로 선언하는 습관을 기르면 프로그램이 훨씬 유연해질 수 있다.

나중에 구현 클래스를 교체하고자 할 때 새 클래스의 생성자를 호출해주기만 하면 된다.

```java
Set<Integer> set = new HashSet<>();
```

단 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 가지고 있고 이 기능을 바탕으로 동작할 경우에는

새로운 클래스도 반드시 같은 기능을 제공해야 한다.

예를 들어 `LinkedHashSet` 을 `HashSet` 으로 변경하면 반복 순회 순서 보장이 안되어 문제가 발생할 수 있다.

<br>

**객체 구현타입이 바뀐다면 이유는??**

- 성능이 좋거나 새로운 기능을 사용하기 위해

<br>

**적합한 인터페이스가 없다면 클래스로 참조한다**

`String` 이나 `BigInteger` 같은 값 클래스가 그렇다.

- 값 클래스는 여러형태로 구현될 것이라 생각하고 설계되지 않으며 `final` 인 경우가 많으며 상응하는 인터페이스가 존재하는 경우가 드물다.

<br>

클래스 기반으로 작성된 프레임워크가 제공하는 객체들이 그렇다.

- 이 경우에도 특정 구현 클래스보다는 추상 클래스 같은 기반 클래스를 사용해 참조하는 게 좋다.

<br>

인터페이스에 없는 특별한 메소드를 제공하는 클래스를 사용할 때 그렇다.

- `PriorityQueue` 같은 경우는 `Queue` 인터페이스에 없는 `comparator` 메소드가 제공되어 해당 타입으로 선언해 초기화한다.

- 이런 클래스 타입을 직접 사용하는 것은 꼭 필요한 경우에만 하도록 하자.


<br>

**요약**

주어진 객체를 표현할 때 적절한 인터페이스가 있는지 찾아 인터페이스로 참조하도록 하자

- 더 유연하고 세련된 프로그램을 만들 수 있다.

적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자

 