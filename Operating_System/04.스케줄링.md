



## CPU 스케줄링


### CPU 스케줄링이란?

- CPU가 하나의 프로세스를 끝내면 다음 프로세스를 진행하는데 어떤 작업에 CPU를 할당하는 지 결정하는 작업을 말한다.

- 어느 프로세스를 선점할지 선택하는 알고리즘을 `CPU Scheduling` 알고리즘이라고 한다.

<br>

### 왜 중요하나

- 어떤 프로세스를 먼저 CPU에 할당하느냐는 시스템의 효율성을 결정한다.


<br>

### 선점 , 비선점 스케줄링

**Preemptive Scheduling**

- 선점형 스케줄링은 한 프로세스가 CPU를 할당받아 작업을 수행할 때 어떤 방해(인터럽트 I/O) 가 없었으며 작업이 완료되지 않았는데도 다른 프로세스가 해당 CPU를 강제로 점유할 수 있는 방식을 말한다.

**Non-preemptive Scheduling**

- 비선점은 한 프로세스가 CPU를 점유하고 있다면 I/O 또는 프로세스 종료 전 까지는 다른 프로세스가 CPU를 점유하지 못하는 방식이다.
- I/O 가 주인 프로세스에서 비선점 방식을 통해 응답시간을 높일 수 있다.


<br>

### 스케줄링 알고리즘

**First-Come-First-Served (FCFS)**

- 먼저 온 프로세스가 먼저 CPU를 차지하며 비선점 스케줄링 방식이다.

- 당연히 먼저 온 프로세스가 수행시간이 길면 뒤에 있는 프로세스들은 오래 대기해야되서 비효율적이어진다.

**Shortest-Job-First(SJF)**

- 가장 짧은 수행시간의 프로세스가 가장 먼저 수행되는 방식이다.

- 이론상으로는 평균대기 시간이 FCFS 에 비해 짧아 사용하면 될 것 같지만 현실에서는 프로세스의 CPU 점유 시간을 정확하게 알 수 없다.

<br>

**우선 순위 스케줄링**

- 우선순위가 높은 프로세스를 먼저 선택한다.

- 다양한 요인들에 의해 우선순위가 결정 된다.

- `기아 현상`이 발생할 수 있다.
	- SJF 에서도 발생할 수 있다.
	- 실제 컴퓨터 환경에서 계속해서 새로운 프로세스가 대기 큐에 들어올텐데 우선순위가 낮은 프로세스들은 계속해서 CPU를 차지하지 못하고 대기만 하게 되는 상황을 말한다
	- `aging` 으로 해결
		- 대기 큐에서 일정 시간 이상 상주했을 시에 우선순위를 높여주는 방식

**RoundRobin**

- 모든 프로세스가 일정한 같은 시간동안 번갈아가며 CPU를 점유하는 방식

- 당연히 선점 방식임

- 정해진 시간 (`Time Quantum`) 에 굉장히 의존적이다.(평균 대기 시간 == 효율 이) 
	- 타임퀀텀이 너무 길면 그냥 FCFS 가 되는 것이고 너무 짧으면 문맥교환 오버헤드가 심해져 시스템 효율이 나빠진다.


**MultiLevel-Queue**

- 프로세스들을 성질에 따라 그룹화하고 각 그룹에 따라 큐를 두어 처리하는 방식

- 큐마다 우선순위를 지정해줄 수 있고 큐마다 다른 스케줄링 방식을 사용할 수 있고 CPU 점유 시간도 다르게 할 수 있다.


**MultiLevel-Feedback-Queue**

- 멀티레벨 큐와 달리 CPU를 사용하고 난 프로세스의 우선순위를 낮춰 원래 큐로 돌아가지 않고 우선순위가 낮은 큐의 끝으로 가게끔 동작시킨다.
	- 우선순위가 낮은 프로세스의 실행이 안되는 문제를 완화한다.
	- 우선순위에 따라 타임퀀텀을 다루게 두어 낮은 우선순위의 프로세스를 CPU에 오래 점유시키게끔 할 수 있다.
		- ~~CPU Burst 위주의 프로세스는 우선순위를 낮춰 긴 시간의 CPU점유를 보장시키고 잦고 응답이 빨라야 하는 I/O Burst 위주의 프로세스는 우선순위를 높여 자주 사용할 수 있게 한다~~ : 솔직히 이거 이해 잘 안됨



