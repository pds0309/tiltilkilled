

## JPA (Java Persistence API)란?


- 데이터 베이스 기술이라기 보다는 애플리케이션의 데이터를 객체 지향 관점으로 바라보고 다룰 수 있게 해주는 `객체 지향 기술`

- 자바 진영의 ORM 기술 표준이다.



**주의점?**

- 객체 관점에서 복잡한 문제를 다루는 데만 집중하다가 데이터 베이스 작업 최적화에 대해 고려하지 않을 수 있다.

-> 객체 지향적으로 데이터를 다루는 법과 함께 데이터 베이스의 성능을 고려한 설정, 개발을 할 수 있어야 한다.


<br>


### ORM?

- `Object Relational Mapping` 은 말 그대로 객체와 관계형 DB를 매핑한다는 뜻이다.

- 객체와 테이블을 매핑해 패러다임의 불일치 문제를 개발자 대신 해결해줌

- ORM을 통해 RDB의 관계를 객체에 반영해 더 객체 지향적인 프로그래밍을 가능하게 해줌

> INSERT 한다고 치면 객체를 마치 자바 컬렉션에 저장하듯 저장하면 된다. 그러면 알아서 적절한 INSERT SQL문을 만들어 DB에 객체를 저장한다.


![jpa1](https://user-images.githubusercontent.com/76927397/163679270-893aa68a-05ce-4d08-82b0-8ca29cf1db8b.JPG)



### JPA?

- 자바 ORM 기술에 대한 API 표준 명세(인터페이스를 모아둔 것)
	- JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다. => `Hibernate` 

**Hibernate**

- 인터페이스인 JPA의 구현체 중 한 종류이다.


<br>


### 왜 쓰나?

**생산성**

- 객체를 컬렉션에 저장하듯 JPA에 전달하기 때문에 단순 쿼리 노동 시간이 줄어든다.

- DB 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

**유지보수**

- SQL을 직접 다루면 엔티티에 필드 하나만 추가해도 관련 SQL과 결과를 매핑하기 위한 JDBC API 코드를 모두 바꿔야 됨

- JPA는 대신 해준다.


**패러다임 불일치 해결**

> 자꾸 뭔 패러다임?

- 다양한 비즈니스 요구사항들을 잘 처리하기 위한 객체 지향적 설계가 필요하지만 온전한 객체 상태 저장을 위해서는 데이터베이스가 필요하다.

- 하지만 데이터베이스와 객체는 목적도 다르고 기능과 표현방법도 다르다. 


> 상속

- 객체는 상속이라는 기능이 있지만 DB 테이블은 없다.

-> 현실에 가깝게 객체지향적으로 설계된 객체가 DB 테이블에서의 사용은 불편할 수 있다.

- `JPA`에서는 자바 컬렉션 쓰듯 저장하고 사용한다. 


> 연관관계

- 객체는 `참조` 를 통해 다른 객체와 연관관계를 가지고 테이블은 `fk` 를 사용해 조인한다.

- 참조를 사용하는 객체와 외래키를 사용하는 RDB 사이의 패러다임 불일치는 객체지향 모델링을 포기하게 만들정도로 극복하기 어렵다.

-> 객체를 테이블에 맞출것인가? : 사용은 쉽겠지만 로직에서 객체지향적인 참조로 사용하는 것은 불가능하다.

-> 그냥 객체지향적으로 모델링할것인가? : 객체를 테이블에 저장하거나 조회하기가 어려워 진다. (개발자가 중간에서 변환 역할을 해야 함)

> 연관관계 In JPA

- 개발자는 객체 지향적으로 참조할 수 있도록 관계를 설정하고 저장하면 된다.
- JPA 가 알아서 참조를 `fk`로 변환해 적절한 작업을 수행한다.


> 객체 그래프 탐색

- SQL을 직접 다뤄 객체를 조회하면 처음에 실행하는 SQL 에 따라 객체 그래프 탐색 가능한 수준이 한정지어진다.

```SQL
SELECT M.*, T.*
FROM  MEMBER M
JOIN    TEAM T 
ON      M.TEAM_ID = T.TEAM_ID
```

- 다음과 같은 SQL 의 결과를 객체에 매핑했을 때 `MEMBER`와 관련된 또 다른 객체는 당연히 탐색할 수 없다.

```java
member.getOrder(); // null
```

- **객체를 보고 어디까지 객체 그래프 탐색이 가능한지를 DAO 를 보기 전 까지는 알 수 가 없다.**

- 매 요청마다 존재하는 모든 연관관계가 있는 객체들을 조회해올 수도 없고 다음과 같이 필요한 상황마다 메소드를 만들어야 할 것이다.

```java

memberDAO.getMember(); // 회원정보만 있음
memberDAO.getMemberWithTeam(); // Member 와 Team 의 조회
memberDAO.getMemberWithOrderWithDelivery(); // 회원과 주문과 배달

```

> 객체 그래프 탐색 In JPA

- `JPA` 에서는 **연관 객체를 사용하는 시점** 에 적절한 SQL 을 실행하기 때문에 연관된 모든 객체를 신뢰하고 사용할 수 있다.
	- `Lazy Loading`



> 비교

- DB는 기본 키 값으로 대조하여 `row` 를 비교

- 객체는 동일성과 동등성 비교 두가지 비교가 있다.
	- 동등성: `equals()` 메소드를 사용해 객체 내부의 값을 비교한다.
	- 동일성: `==` 을 통해 객체 인스턴스의 주소값을 비교한다.

- ORM 없이 같은 조회를 두번 하고 각각 다른 클래스 변수에 넣으면 동일성 `==` 비교에서 같을 수 없다.
	- 같은 DB 테이블의 `row` 결과지만 자바로 가져오면 다른 객체처럼 보이게 된다.


> 비교 In JPA

- `JPA`는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장해준다.


```java
Member m1 = repo.findById(100);
Member m2 = repo.findById(100);
m1 == m2; // true
```

<br>

**성능**

- `JPA` 는 Application 과 Database 사이에서 동작하기 때문에 다양한 성능 최적화의 방법이 있을 수 있다.


**데이터 접근 추상화와 벤더 독립성**

- 애플리케이션과 데이터 베이스 사이에 추상화된 접근 계층을 제공해 특정 dbms 에 종속되지 않을 수 있게 해준다.
- DB변경 시 어떤 DB인지만 알려주면 됨



<br>


## Vs Mybatis

- 마이배티스는 SQL 매퍼로 이름 그대로 객체와 SQL을 매핑하는 것이다.
	- SQL에 의존된 개발을 할 수 밖에 없다.

- ORM은 객체와 테이블을 매핑만 하면 알아서 SQL 만들어서 처리해주기 때문에 SQL 에 의존적이지 않은 개발이 가능



