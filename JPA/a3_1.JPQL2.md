



### 벌크 연산

엔티티 수정 시 영속성 컨텍스트 변경 감지나 병합을 사용하고 삭제할 때는 `remove()` 메소드 사용함

- 이 방법으로 수백 개 넘는 엔티티를 하나씩 처리하기에는 시간이 너무 오래걸리는데 이를 해결해줄 수 있는 일괄적인 수정,삭제가 가능한 **벌크연산** 이 있다.

- 벌크 연산은 `executeUpdate()` 메소드 사용

> UPDATE 벌크 연산 예시

```java

String sql = "uupdate Product p set p.price = p.price * 1.1 where p.stockAmount < :stockAmount";

int resultCount = em.createQuery(sql).setParameter("stockAmount", 10).executeUpdate();

```


**벌크 연산 사용시 주의할 점**

- 벌크 연산이 `영속성 컨텍스트`를 무시하고 DB에 직접 쿼리한다는 점을 주의해야 함

![jpa7](https://user-images.githubusercontent.com/76927397/165420064-0fa41d49-1a34-406d-b722-292b6848c129.JPG)


- 영속성 컨텍스트에서 관리되는 객체를 가지고 벌크연산하고 객체로 부터 결과를 가져와도 영속성 컨텍스트를 거쳐서 DB에 업데이트 한게 아니기 때문에 의도한 결과가 안나올 수 있다.



<br>

**해결하기**

- em.refresh()
	- 벌크 연산 수행 직후 정확한 엔티티를 사용해야 한다면 `refresh()` 를 사용해 DB에서 다시 조회해온다.

- 벌크 수행 후 영속성 컨텍스트 초기화
	- 벌크 연산 한 뒤 영속성 컨텍스트 초기화해서 남아있는 엔티티 제거하기
	- 제거하면 조회할 때 DB로부터 직접 가져오기 때문임

- 벌크 연산부터 실행
	- 벌크 연산부터 가장 먼저 실행하고 조회하면 변경되어진 엔티티 객체를 조회해올 것이다.


<br>


### 영속성 컨텍스트와 JPQL

**쿼리 후 영속 상태인  것과 아닌 것**

- `JPQL` 의 조회 대상은 엔티티, 임베디드 타입, 값 타입 등 다양한 종류가 있는데 엔티티만 영속 대상임

- 즉 조회한 엔티티만 영속성 컨텍스트가 관리한다. 


**영속성 컨텍스트에 이미 있는 객체를 JPQL로 다시 조회하면?**

- jpql로 DB에서 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 조회 결과를 버리고 영속성 컨텍스트에 있던 엔티티를 반환한다.
	- 영속 상태의 엔티티의 동일성을 보장한다.


**JPQL은 항상 DB에서 SQL을 실행해 결과를 조회한다.**

- `em.find()` 같이 조회해오면 영속성 컨텍스트에서 먼저 객체를 찾아보고 DB를 찾음(1차캐시)

- JPQL은 영속성 컨텍스트와 상관 없이 항상 DB로 부터 결과를 조회해온다. (DB로 부터 조회해와도 영속성 컨텍스트에 이미 존재하는 객체와의 동일성은 보장됨)


<br>

**JPQL 특징 요약**

- 항상 DB로 부터 먼저 값을 조회해온다.

- JPQL로 조회해온 엔티티 객체는 영속 상태이다.

- 이미 영속성 컨텍스트에 있는 엔티티에 대해서는  (조회해도) 기존 엔티티를 반환한다.


<br>




