



## 영속성 컨텍스트가 엔티티를 관리하면..


- 1차 캐시

- 동일성 보장

- 트랜잭션을 지원하는 쓰기 지연

- 변경 감지

- 지연 로딩


<br>

<br>


### 1차 캐시?

- `영속성 컨텍스트` 는 내부에 캐시를 가지고 있는데 이걸 `1차 캐시` 라고 한다.

- 영속 상태의 엔티티는 모두 이곳에 저장된다.

- 마치 Map 처럼 Key, Value 구조로 식별자를 키로하여 캐시에 저장된다.

- 조회 시 먼저 1차 캐시에서 엔티티를 찾고 없으면 DB에서 조회해온다.

- DB까지 안가고 메모리에 있는 1차 캐시를 활용하기에 성능상 매우 이득이다.


<br>

### 동일성 보장

한 트랜잭션에서 다음과 같이 조회 해오면 두 객체는 같을까?

```java

Member m1 = em.find(Member.class , "mkey1");
Member m2 = em.find(Member.class , "mkey1");

// a==b ?

```

- 두 객체는 같다. (`실제 인스턴스 자체가 동일하다`)

**왜요?**

- m1 엔티티 객체를 얻어올때 DB 로 부터 `mkey1` 에 대한 엔티티를 얻고 1차 캐싱이 된다.
- m2 엔티티 객체를 얻어올때는 1차 캐시로부터 얻어오게 된다.

<br>


### 트랜잭션을 지원하는 쓰기 지연

엔티티를 영속성 컨텍스트에 등록한다고 생각하자

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지는 DB에 삽입하지 않고 내부 `쿼리 저장소` 에 삽입 쿼리문을 쌓아둔다.

- 트랜잭션 커밋 시점에 모아둔 쿼리를 DB에 보내 삽입하는데 이를 `쓰기 지연(transactional write-behind)` 라고 한다.

- 하나의 트랜잭션에서 작업을 하면 (삽입,수정 등) 영속성 컨텍스트에 등록하여 영속화 할텐데 트랜잭션 커밋 시점에 이 것들을 `flush(DB와 동기화)` 한다.(지연 SQL 저장소에 모인 쿼리를 DB에 보낸다.)


<br>


### 변경 감지(Dirty Checking)

이번에는 엔티티를 수정한다고 생각 해보자

- 기존의 SQL 사용 방식에서는 수정 쿼리를 직접 작성해야 하고 비즈니스 요구사항이 바뀌거나 추가되면 같이 바뀐다.

> 상황에 따라 수정 쿼리 자체를 추가하거나 수정해야 되며 다양한 예외 상황의 추가에 대해 대처해야 되서 SQL 에 비즈니스가 의존적이게 된다.


- JPA 에서는 변경을 감지하여 DB에 반영하기 때문에 그냥 영속 대상 엔티티를 수정하고 커밋하면 끝이다.


**어케함?**

- JPA는 처음 영속성 컨텍스트에 엔티티를 보관하게 될 때 `스냅샷`을 남긴다.

- 영속성 컨텍스트 `Flush` 시점에 스냅샷과 엔티티를 비교해 변경 여부를 감지해 반영하는 것이다.

- 당연히 `영속 상태`의 엔티티에만 적용된다.


**수정쿼리는?**

- JPA 기본 전략은 모든 컬럼에 대한 수정 쿼리로 반영하는 것이다.
	- DB에 보내는 데이터 전송량이 증가하는 단점이 있다.
	- 수정 쿼리가 항상 같아 애플리케이션 로딩 시점에 생성해둬 재사용 가능하다는 장점
	- DB 자체에서도 한 번 파싱된 쿼리를 재사용 한다는 장점

- 필드 30개 이상일 경우 동적 수정 쿼리 전략 사용이 권장됨
	- `@DynamicUpdate`

<br>


### 지연 로딩

- 프록시 객체를 사용하여 연관관계 매핑 객체에 대해 조회를 미뤄뒀다가 해당 객체 사용 시점에 조회해오는 것을 말한다.

- 초기 로딩 시간을 줄이고 메모리 소비량을 감소시킬 수 있다.







