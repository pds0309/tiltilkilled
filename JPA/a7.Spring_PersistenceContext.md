


## 웹 애플리케이션과 영속성

- 스프링 환경에서 JPA를 사용하면 컨테이너가 트랜잭션과 영속성 컨텍스트를 관리해주나 컨테이너 환경에서 JPA 내부 동작 방식을 이해하고 있어야 한다.


<br>

### 스프링 컨테이너의 기본 전략

**트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용**

- 트랜잭션 범위와 영속성 컨텍스트 생존 범위가 같다

**스프링에서 보통 비즈니스 로직을 시작하는 서비스 계층에 `@Transactional` 어노테이션을 선언해 트랜잭션을 시작함**

- 이 어노테이션이 있을 경우 스프링의 `트랜잭션 AOP` 가 먼저 동작함
- 컨트롤러로부터 호출받은 메소드 수행 전 AOP가 트랜잭션을 시작하고 메소드 정상 종료 시 트랜잭션을 커밋한다.
	- 이 때 `JPA`는 먼저 영속성 컨텍스트를 `플러쉬` 해서 DB에 반영한다.

- 예외가 발생하면 트랜잭션이롤백하며 이 때는 `플러시`를 호출하지 않음

<br>



**트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다**

- 다양한 위치에서 엔티티 매니저를 주입받아 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용한다.

**트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다**

- 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.
	- 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다.
	- 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 달라 `Thread-Safe` 함
	- 스프링 컨테이너가 트랜잭션과 복잡한 멀티 스레드 상황을 알아서 처리해주기 때문에 개발자는 싱글 스레드 인것 마냥 단순하게 개발할 수 있다.


<br>


### 준영속 상태

- 스프링 컨테이너에 의해 트랜잭션 범위(영속성 컨텍스트) 는 서비스에서 시작해 서비스에서 종료하게 된다.
	- 컨트롤러나 뷰 같은 계층에서의 엔티티 객체는 `준영속 상태`임
	- 따라서 `변경감지` 나 `지연로딩` 이 불가능하다.

```java

@Controller
public class HelloController {

	public String hi(Long id) {
		Hi hi = hiService.findOne(id);
		Hello hello = hi.getHello();
		hello.getName(); // 지연 로딩 시 예외 발생	
	}

}
```


**변경감지 문제??**

- 문제 없음
	- 비즈니스 로직을 수행하면서 발생되는 일이라 서비스 계층에서 끝낼 수 있도록 분리된 환경인 것이라고 보면 됨
	- 프레젠테이션 레이어와 책임 분리


**지연로딩 문제!**

- 뷰를 렌더링할 때 연관 엔티티도 함께 사용해야하는데 지연로딩 설정이 되어있을 경우 준영속 상태에서는 실제 데이터를 불러올 수 없음.

- `LazyInitializationException`

- 해결하기
	- 글로벌 페치 전략 수정 
	- JPQL 페치 조인
	- 강제 초기화


 